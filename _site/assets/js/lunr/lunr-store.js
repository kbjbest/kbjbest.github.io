var store = [{
        "title": "[웹 에디터] 코드 미리보기, 코드삽입 사이트 codepen",
        "excerpt":"codepen : Front-end designer playground  작성한 HTML, CSS, JavaScript에 코드의 결과를 알려주는 웹사이트이다. 또한 작업한 것을 자신의 블로그나 개인홈페이지에 삽입 할 수 있다.   1. http://codepen.io/ 여기 회원가입해야한다.  2. Create 버튼을 클릭한다.    3. 소스를 적고 Save버튼을 클릭한다.    4. 저장 후 우측하단에 Embed버튼을 클릭하면 Embed This Pen 팝업이 뜨고 맨 아래 코드를 복사한다.    5. 자신이 쓰는 글을 HTML형식으로 바꾼 후 Copy &amp; Paste하면 끝!  See the Pen KbevWj by Beomju Kim (@kbjbest) on CodePen.    ","categories": ["Editor"],
        "tags": ["web editor","source coding tool"],
        "url": "http://localhost:4000/editor/codepen/",
        "teaser":null},{
        "title": "[HTML] 알면 유용하거나 자세히 몰랐던 HTML 소스",
        "excerpt":"HTML TAG : Learning the HTML Source  내가 작업하면서 알게 된 것이나 유용한 HTML 관련 소스들을 정리하는 목적에 블로깅이며 계속 업데이트 할 것이다.   1. &lt;intut type=”text” required&gt;   input 태그에 필수 값 처리를 해주는 방법으로 알아서 유효성 처리를 해준다. 회원가입 같은 페이지 만들 때 활용할 수 있다.     2. label, radio   input과 label을 연동시키지 않으면 label을 눌렀을 때 라디오 버튼이 선택되지 않는다. 연동시키는 방법에는     label태그로 input태그를 감싸는 방법과,   label태그에 input의 ID를 지정해주는 방법이 있다. checked=’checked’ 대신 checked만 써도 되지만, 표준 문법에 맞는 것은 전자이므로 FM들은 전자를 쓰기바람..ㅎㅎ(근데 나도 약간 FM스타일)   예시1)라벨감싸기  &lt;label&gt;&lt;input TYPE='radio' name='group1' value='apple' /&gt;사과&lt;/label&gt; &lt;label&gt;&lt;input TYPE='radio' name='group1' value='banana' /&gt;바나나&lt;/label&gt; &lt;label&gt;&lt;input TYPE='radio' name='group1' value='lemon' checked='checked' /&gt;레몬&lt;/label&gt;   예시2)ID지정  &lt;input TYPE='radio' id='r1' name='group1' value='apple' /&gt; &lt;label for='r1'&gt;사과&lt;/label&gt; &lt;input TYPE='radio' id='r2' name='group1' value='banana' /&gt; &lt;label for='r2'&gt;바나나&lt;/label&gt; &lt;input TYPE='radio' id='r3' name='group1' value='lemon' checked='checked' /&gt; &lt;label for='r3'&gt;레몬&lt;/label&gt;   ","categories": ["HTML"],
        "tags": ["HTML","tag"],
        "url": "http://localhost:4000/html/html-tag/",
        "teaser":null},{
        "title": "블로그 포스팅 소스 작성 요령",
        "excerpt":"abc : 대제목  abc : 중제목  abc : 소제목  abc : 굵게     abc   def : 넘버링            abc : 목록    : 이미지 삽입   ______________________ : 경계선           codeblock 예시  function syntaxHighlight(code) {    var foo = 'Hello World';    var bar = 100; }  ","categories": ["Blogging"],
        "tags": ["markdown"],
        "url": "http://localhost:4000/blogging/sample-source/",
        "teaser":null},{
        "title": "JAVA Thread 사용하기",
        "excerpt":"public class ThreadTest implements Runnable {   @Override  public void run() {   while (true) {        System.out.println(\"***** &lt;&lt;\" + Thread.currentThread().getName()  + \"&gt;&gt; *****\");         try {     Thread.sleep(1000);    } catch (InterruptedException e) {     e.printStackTrace();    }       aMethod();   }  }   public void aMethod() {    Thread.dumpStack();  //현재 메소드와 콘솔 스트림을 호출하는 모든 메소드 출력    }      public static void main(String[] args) {        // 두개의 쓰레드 생성   Thread t1 = new Thread(new ThreadTest(), \"첫번째 쓰레드\");   t1.start();    Thread t2 = new Thread(new ThreadTest(), \"두번째 쓰레드\");   t2.start();      // 쓰레드에 대한 정보 출력   int threadCnt = Thread.activeCount(); // 실행중인 쓰레드의 갯수   Thread[] threads = new Thread[threadCnt];    Thread.enumerate(threads); // 인수로 받은 배열을 실행중인 쓰레드로 채운다.         for (int i = 0; i &lt; threadCnt; i++) {      Thread t = threads[i];       System.out.println(\"쓰레드의 이름은 : \" + t.getName());    }   }  }    출처: https://javafactory.tistory.com/1365 [FreeLife의 저장소]  ","categories": ["Java"],
        "tags": ["Thread","run()","start()"],
        "url": "http://localhost:4000/java/Thread.dumpStack()/",
        "teaser":null},{
        "title": "synchronized",
        "excerpt":"synchronized 기본 개념  둘 이상의 쓰레드가 공동의 자원(파일이나 메모리 블록)을 공유하는 경우, 순서를 잘 맞추어 다른 쓰레드가 자원을 사용하고 있는 동안 한 쓰레드가 절대 자원을 변경할 수 없도록 해야 한다. 한 쓰레드가 파일에서 레코드를 수정하는데, 다른 쓰레드가 동시에 같은 레코드를 수정하면 심각한 문제가 발생할 수 있다. 이런 상황을 처리할 수 있는 한 방법은 관련된 쓰레드에 대한 동기화(synchronization)를 이용하는 것이다.   동기화의 목적은 여러 개의 쓰레드가 하나의 자원에 접근하려 할 대 주어진 순간에는 오직 하나의 쓰레드만이 접근 가능하도록 하는 것이다. 동기화를 이용해 쓰레드의 실행을 관리할 수 있는 방법은 두 가지가 있다.      코드를 메소드 수준에서 관리할 수 있다. - 동기화 메소드   코드를 블록 수준에서 관리할 수 있다. - 동기화 블록   동기화 메소드와 동기화 블록은 모두 synchronized를 이용하여서 구현된다. synchronized는 어떤 객체에서도 특정 문장 블록에 대해 lock설정을 할 수 있다. 사용방법은 아래와 같다.  synchronized(theObject) \tstatement;\t // theObject가 동기화된다.  synchronized(theObject) { \tstatement;\t // theOjbect가 동기화된다. }   statement문장이 실행되는 동안 theObject는 동기화된 다른 쓰레드에서 사용할 수  없다. 동기화된 다른 쓰레드라는 것은 위의 코드와 동일하게 synchronized를  사용하였거나 synchronized method를 사용한 쓰레드를 의미한다. synchronized  method의 예제는 아래와 같다.  class theObject {  \tsynchronized public void method() {  \t\tstatement;  \t} }    synchronized block VS synchronized method  synnchronized method가 synchronized block보다 나은 특별한 장점은 없다. 굳이 하나를 뽑자면 this라는 오브젝트 레퍼런스를 포함시킬 필요가 없다는건데 이것도 그렇게 큰 장점이라고는 볼 수 없다.   method  public synchronized void method() { //block이었으면 this를 넣어야 함 \t... \t... \t... }   block  public void method() { \tsynchronized(this) { // this를 넣음 \t\t... \t\t... \t\t... \t} }   synchronized block이 synchronized method보다 많은면에서 유연하다. 왜냐하면 synchronized method는 메소드 전체의 lock을 걸지만 block은 다른객체를 사용하여 특정 부분에 lock을 걸 수 있기 때문이다.  //객체 전체를 잠금 ... private synchronized void someInputRelatedWork() { \t... } private synchronized void someOutputRelatedWork() { \t... }  Vs.  // 특정 부분만 잠금 Object inputLock = new Object(); Object outputLock = new Object();  private void someInputRelatedWork() { \tsynchronize(inputLock) { \t\t... \t} } private void someOutputRelatedWork() { \tsynchronize(outputLock) { \t\t... \t} }  또 synchronized block을 사용하게 되면 밑의 코드처럼 메소드 내에서 필요한 부분만 lock을 걸 수 있다.  private void method() { \t... 코드 \t... 코드 \t... 코드 \tsynchronized(lock) { \t\t... 코드 \t} \t... 코드 \t... 코드 \t... 코드 \t... 코드 }   출처: https://hashcode.co.kr [Hashcode]  ","categories": ["Java"],
        "tags": ["synchronized"],
        "url": "http://localhost:4000/java/synchronized/",
        "teaser":null}]
